using System;

/* 

 옵저버 패턴은 게임 개발에서 매우 매우 중요하다. 물론 패턴을 쓰지 않아도 게임 개발을 하는 데는 지장이 없다.
하지만 클래스를 사용하면서 옵저버 패턴을 사용하지 않는다면 OOP 원칙과 거리가 멀어지기 때문에 (특히 캡슐화 원칙을 깨게 된다)
그럴 거면 차라리 절차지향 프로그래밍을 권하고 싶다! 하나를 수정하면 다른 코드도 전부 수정해야하는 엄청난 스파게티 코드가 될 수 있다!

게임의 장비를 예를 들어보자. 아이템을 장착하면 스킬 레벨이 오를 수도 있고, 능력치가 바뀔 수도 있으며, 캐릭터의 외형이 바뀔 수도 있다.
이 예시 하나만으로도 수많은 객체들 사이에 간섭이 일어나는 것을 짐작할 수 있을 것이다.

또 한 가지 예시로, 몬스터가 스킬에 피격 당했을 때는 어떤 스킬을 맞았는지에 대한 정보를 필요로 한다. 그리고 언제 맞았는지도 중요하다. 
그때 데미지를 받거나 특수 디버프 등이 발생하기 때문이다. 프로그래밍을 얼마 접하지 않은 사람들이 코드를 짠다면,
'플레이어 클래스에서 몬스터를 참조해 스킬 피격 처리를 해줄 것인가?' '몬스터 클래스에서 플레이어를 참조해 스킬 피격 처리를 해줄 것인가?' 고민을 하게 된다.
닭이 먼저냐 달걀이 먼저냐의 논리였지만 그때는 왜 이런 고민을 했는지 모르겠다. 적어도 OOP에서는 둘 다 이상적이지 않다(아무튼 쓸데 없는 것까지도 참조해야한다).
정답은 '스킬 피격을 감지할 수 있는 몬스터 클래스'를 만드는 것이다.

1. 플레이어는 몬스터에게 스킬을 쓰는 행위를 했고, 
2. 몬스터는 플레이어의 자잘한 정보까진 알 필요가 없다.

즉 몬스터는 '어떤' 스킬을 '언제' 받았는지 감지하는 기능만 있으면 된다.

이게 옵저버 패턴의 역할이며, 이러한 이벤트 처리 방식은 리액티브 프로그래밍 패러다임에 기초가 된다.

*/

class Player 
{
	static void Main( string[] args )
	{
		// 플레이어가 인벤토리에서 무기를 장착하면, 캐릭터의 스테이터스와 모델에 변화가 생긴다.
		// 즉, 인벤토리 내에서 어떤 아이템을 장착하면 캐릭터의 모델과 스테이터스 객체가 이 상태의 변화를 통보를 받는다.
		// 1:n의 관계로서 객체 간 느슨한 결합을 통해 상태의 변화를 통보하는 것이 옵저버 패턴이다.
		// 필요한 정보는 장착된 시점과, '어떤 아이템을 장착했느냐' 뿐이다.
		// 옵저버 패턴은 이 최소한의 정보만을 제공하고 ( 캐릭터 스테이터스, 모델 ) ↔ 인벤토리의 의존성을 디커플링시킨다.
		// 인벤토리의 정보를 알 필요가 없는 것이다.
		// 이러한 설계는 OCP(개방 폐쇄) 원칙을 수용하여 확장에는 열려있고 수정에는 닫혀있다.

		Inventory			inventory	= new Inventory();			// Observerable - 인벤토리의 상태를 관찰할 수 있는 클래스다.
		CharacterModel		model		= new CharacterModel();		// Observer - 
		ChartacterStatus	status		= new ChartacterStatus();   // Observer

		// Sbuscrible 
		inventory.AddEquipObserver( model );
		inventory.AddEquipObserver( status );

		// 만약 추후 채팅창에 'X 아이템을 장착하였습니다.' 라는 메세지를 추가 해달라는 기획 요청 건이 들어왔다.
		// ChatArea 클래스는 OnEquip 인터페이스를 가지고, 인벤토리에서는 아래와 같은 옵저버를 추가해주기만 하면된다.
		// ChatArea에서는 인벤토리 자체를 참조할 필요가 없으며, 코드와 구조가 훨씬 깔끔해진다. 단순히 '장착을 감지할 수 있는 ChatArea'의 역할로서
		// 자기주도적인 클래스가 되는 것이다.
		// inventory.AddEquipObserver( chatArea );

		inventory.Equip( new Item() );
	}
}